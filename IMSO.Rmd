---
title: "Integrated multispecies occupancy model for bottlenose dolphins and fisheries in the Gulf of Lion, French Mediterranean Sea"
author: "Valentin Lauret, Olivier Gimenez"
date: "`r format(Sys.time(), '%d/%m/%Y')`"
output: 
  pdf_document:
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, results = 'hide', 
                      dpi = 300, 
                      cache = TRUE)
library(tidyverse)
theme_set(theme_light())
library(sf)
library(nimble)
library(patchwork)
```

# An ounce of theory

We consider a two-species static occupancy model à la [Rota et al. (2016)](https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.12587).

Ignoring the site index, we use the following notation for the occupancy probabilities:

-   $\psi_{11}$ is the prob. that species A and species B are both present;\
-   $\psi_{10}$ is the prob. that species A is present and species B is absent;
-   $\psi_{01}$ is the prob. that species A is absent and species B is present;
-   $\psi_{00}$ is the prob. that species A and species B are both absent, with avec $\psi_{11} + \psi_{10} + \psi_{01} + \psi_{00} = 1.$

The marginal probabilities of occupancy are:

-   $\Pr(z_A = 1) = \Pr(\mbox{species A is present}) = \psi_{10} + \psi_{11}$
-   $\Pr(z_B = 1) = \Pr(\mbox{species B is present}) = \psi_{01} + \psi_{11}$
-   $\Pr(z_A = 0) = \Pr(\mbox{species A is absent}) = \psi_{01} + \psi_{00}$
-   $\Pr(z_B = 0) = \Pr(\mbox{species B is absent}) = \psi_{10} + \psi_{00}$

And the conditional probabilities (reminder: $\Pr(\mbox{A|B}) = \Pr(\mbox{A and B})/\Pr(\mbox{B})$):

-   $\Pr(z_A = 1 | z_B = 0) = \psi_{10} / (\psi_{10} + \psi_{00}) = \Pr(\mbox{species A is present given species B is absent});$
-   $\Pr(z_A = 1 | z_B = 1) = \psi_{11} / (\psi_{11} + \psi_{01}) = \Pr(\mbox{species A is present given species B is present});$
-   $\Pr(z_B = 1 | z_A = 0) = \psi_{01} / (\psi_{01} + \psi_{00}) = \Pr(\mbox{species B is present given species A is absent});$
-   $\Pr(z_B = 1 | z_A = 1) = \psi_{11} / (\psi_{11} + \psi_{10}) = \Pr(\mbox{species B is present given species A is present}).$

In this document, we adapted the multi-species occupancy to integrate two datasets. We considered dataset `S` (e.g SAMM aerial line transects), and dataset `G` (e.g. GDEGeM boat search-encounter program). Both monitoring collected detection / non-detection about species A and B. Then, each species has a different detection probability depending on the monitoring program considered. For example, $p_{A}^{G}$ is the probability of detecting species A by monitoring program 'g'. Then, 16 observation 'event' can occur. We coded them:

-   `1` for none species detected neither by G nor S
-   `2` for species A detected by G, nothing by S
-   `3` for species B detected by G, nothing by S
-   `4` for both species detected by G, nothing by S
-   `5` for none species detected neither by G, species A detected by S
-   `6` for species A detected by G, species A detected by S
-   `7` for species B detected by G, species A detected by S
-   `8` for both species detected by G, species A detected by S
-   `9` for none species detected neither by G, species B detected by S
-   `10` for species A detected by G, species B detected by S
-   `11` for species B detected by G, species B detected by S
-   `12` for both species detected by G, species B detected by S
-   `13` for none species detected neither by G, both species detected by S
-   `14` for species A detected by G, both species detected by S
-   `15` for species B detected by G, both species detected by S
-   `16` for both species detected by G, both species detected by S

From the 4 ecological states and the 16 observation events, we obtaine the observation process with the following 4x16 matrix.

$$  t(\theta ) = \begin{bmatrix} 1 & (1 - p_{A}^{G})(1 - p_{A}^{S}) & (1 - p_{B}^{G})(1 - p_{B}^{S}) & (1 - p_{B}^{G})(1 - p_{B}^{S})(1 - p_{A}^{S})(1 - p_{A}^{G}) \\
0&  p_{A}^{G}(1- p_{A}^{S})  &0 &(1 - p_{B}^{S})(1 - p_{A}^{S})p_{A}^{G}(1-p_{B}^{G}) \\
0& 0 & p_{B}^{G}(1- p_{B}^{S})  &(1 - p_{B}^{S})(1 - p_{A}^{S})p_{B}^{G}(1-p_{A}^{G}) \\
 0&  0 &0 &(1 - p_{B}^{S})(1 - p_{A}^{S})p_{A}^{G}p_{B}^{G} \\
 0& p_{A}^{S}(1-p_{A}^{G})  &0   &p_{A}^{S}(1-p_{B}^{S})(1-p_{A}^{G})(1-p_{B}^{G}) \\
0& p_{A}^{G}p_{A}^{S} &0  &p_{A}^{S}(1-p_{B}^{S})p_{A}^{G}(1-p_{B}^{G}) \\
 0& 0  &0  &p_{A}^{S}(1-p_{B}^{S})p_{B}^{G}(1-p_{A}^{G}) \\
 0&  0  &0  &p_{A}^{S}(1-p_{B}^{S})p_{A}^{G}p_{B}^{G}\\
0& 0 &0  &p_{B}^{S}(1-p_{A}^{S})(1-p_{A}^{G})(1-p_{B}^{G}) \\
0& 0  &p_{B}^{G}p_{B}^{S}  &p_{B}^{S}(1-p_{A}^{S})p_{A}^{G}(1-p_{B}^{G}) \\
0& 0& 0  &p_{B}^{S}(1-p_{A}^{S})p_{B}^{G}(1-p_{A}^{G}) \\
0& 0& 0   &p_{B}^{S}(1-p_{A}^{S})p_{B}^{G}p_{A}^{G} \\
0& 0& 0   &p_{A}^{S}p_{B}^{S}(1-p_{B}^{G})(1-p_{A}^{G}) \\
0& 0& 0    &p_{A}^{S}p_{B}^{S}p_{A}^{G}(1-p_{B}^{G})\\
0& 0& 0  &p_{A}^{S}p_{B}^{S}p_{B}^{G}(1-p_{A}^{G}) \\
0& 0& 0  &p_{B}^{G}p_{B}^{S}p_{A}^{G}p_{A}^{S}\\
\end{bmatrix}$$

```{r eval=FALSE, include=FALSE}
$$\theta = \begin{bmatrix} 1 & 0& 0& 0& 0& 0& 0& 0& 0& 0& 0& 0& 0& 0& 0& 0\\
(1 - p_{A}^{G})(1 - p_{A}^{S}) & p_{A}^{G}(1- p_{A}^{S}) &0 &0 & p_{A}^{S}(1-p_{A}^{G}) &p_{A}^{G}p_{A}^{S} &0 &0 &0 &0&0 &0&0 &0&0 &0\\
(1 - p_{B}^{G})(1 - p_{B}^{S}) &0 & p_{B}^{G}(1- p_{B}^{S}) &0 &0 &0 &0 &0 &p_{B}^{S}(1-p_{B}^{G}) &0 &p_{B}^{G}p_{B}^{S}&0 &0&0 &0&0 \\

(1 - p_{B}^{G})(1 - p_{B}^{S})(1 - p_{A}^{S})(1 - p_{A}^{G}) &(1 - p_{B}^{S})(1 - p_{A}^{S})p_{A}^{G}(1-p_{B}^{G}) &(1 - p_{B}^{S})(1 - p_{A}^{S})p_{B}^{G}(1-p_{A}^{G}) &(1 - p_{B}^{S})(1 - p_{A}^{S})p_{A}^{G}p_{B}^{G} &p_{A}^{S}(1-p_{B}^{S})(1-p_{A}^{G})(1-p_{B}^{G}) &p_{A}^{S}(1-p_{B}^{S})p_{A}^{G}(1-p_{B}^{G}) &p_{A}^{S}(1-p_{B}^{S})p_{B}^{G}(1-p_{A}^{G}) &p_{A}^{S}(1-p_{B}^{S})p_{A}^{G}p_{B}^{G} &p_{B}^{S}(1-p_{A}^{S})(1-p_{A}^{G})(1-p_{B}^{G}) &p_{B}^{S}(1-p_{A}^{S})p_{A}^{G}(1-p_{B}^{G}) &p_{B}^{S}(1-p_{A}^{S})p_{B}^{G}(1-p_{A}^{G}) &p_{B}^{S}(1-p_{A}^{S})p_{B}^{G}p_{A}^{G} &p_{A}^{S}p_{B}^{S}(1-p_{B}^{G})(1-p_{A}^{G}) &p_{A}^{S}p_{B}^{S}p_{A}^{G}(1-p_{B}^{G}) &p_{A}^{S}p_{B}^{S}p_{B}^{G}(1-p_{A}^{G}) &p_{B}^{G}p_{B}^{S}p_{A}^{G}p_{A}^{S}
\end{bmatrix}$$
  
  ## transposé 
  \theta = \begin{bmatrix} 1 & (1 - p_{A}^{G})(1 - p_{A}^{S}) & (1 - p_{B}^{G})(1 - p_{B}^{S}) & (1 - p_{B}^{G})(1 - p_{B}^{S})(1 - p_{A}^{S})(1 - p_{A}^{G}) \\
0&  p_{A}^{G}(1- p_{A}^{S})  &0 &(1 - p_{B}^{S})(1 - p_{A}^{S})p_{A}^{G}(1-p_{B}^{G}) \\
0& 0 & p_{B}^{G}(1- p_{B}^{S})  &(1 - p_{B}^{S})(1 - p_{A}^{S})p_{B}^{G}(1-p_{A}^{G}) \\
 0&  0 &0 &(1 - p_{B}^{S})(1 - p_{A}^{S})p_{A}^{G}p_{B}^{G} \\
 0& p_{A}^{S}(1-p_{A}^{G})  &0   &p_{A}^{S}(1-p_{B}^{S})(1-p_{A}^{G})(1-p_{B}^{G}) \\
0& p_{A}^{G}p_{A}^{S} &0  &p_{A}^{S}(1-p_{B}^{S})p_{A}^{G}(1-p_{B}^{G}) \\
 0& 0  &0  &p_{A}^{S}(1-p_{B}^{S})p_{B}^{G}(1-p_{A}^{G}) \\
 0&  0  &0  &p_{A}^{S}(1-p_{B}^{S})p_{A}^{G}p_{B}^{G}\\
0& 0 &0  &p_{B}^{S}(1-p_{A}^{S})(1-p_{A}^{G})(1-p_{B}^{G}) \\
0& 0  &p_{B}^{G}p_{B}^{S}  &p_{B}^{S}(1-p_{A}^{S})p_{A}^{G}(1-p_{B}^{G}) \\
0& 0& 0  &p_{B}^{S}(1-p_{A}^{S})p_{B}^{G}(1-p_{A}^{G}) \\
0& 0& 0   &p_{B}^{S}(1-p_{A}^{S})p_{B}^{G}p_{A}^{G} \\
0& 0& 0   &p_{A}^{S}p_{B}^{S}(1-p_{B}^{G})(1-p_{A}^{G}) \\
0& 0& 0    &p_{A}^{S}p_{B}^{S}p_{A}^{G}(1-p_{B}^{G})\\
0& 0& 0  &p_{A}^{S}p_{B}^{S}p_{B}^{G}(1-p_{A}^{G}) \\
0& 0& 0  &p_{B}^{G}p_{B}^{S}p_{A}^{G}p_{A}^{S}\\
\end{bmatrix}
```

Let's go for the analysis.

# Format and visualise data

Load grid and occupancy data.

```{r message=FALSE, warning=FALSE, echo = FALSE}
load("pays.rdata")
grid <- st_read("Grid/grid.shp") %>% st_transform(crs = st_crs(pays))
load("sea.grid.rdata")
  
# focus Golfe du Lion
grid <-  grid %>% st_crop(xmin = 700000, xmax = 900000, ymin = 6140000, ymax = 6300000) 
pays <- pays %>% st_crop(st_bbox(grid))

sea <- st_transform(sea, crs = st_crs(grid))
mt <- st_crop(sea,grid)

# SAMM data
load('msoccu_samm.rdata')
multioccu_samm$dauphins <- st_transform(multioccu_samm$dauphins, st_crs(grid))
multioccu_samm$chalut <- st_transform(multioccu_samm$chalut, st_crs(grid))
multioccu_samm$effort <- st_transform(multioccu_samm$effort, st_crs(grid))

# GDEGeM data
load('msoccu_gd.rdata')
multioccu_gd$dauphins <- st_transform(multioccu_gd$dauphins, st_crs(grid))
multioccu_gd$chalut <-   st_transform(multioccu_gd$chalut, st_crs(grid))
multioccu_gd$effort <-   st_transform(multioccu_gd$effort, st_crs(grid))
```

## SAMM

Visualise data.

```{r message=FALSE, warning=FALSE, echo = FALSE}
dfS <- bind_rows(multioccu_samm$dauphins %>% add_column(species = "dauphin"), 
          multioccu_samm$chalut %>% add_column(species = "chalutier")) %>% 
  st_crop(st_bbox(grid))

```

Build datasets.

```{r message=FALSE, warning=FALSE, echo = FALSE}
# sampling effort
effortS <- multioccu_samm$effort %>% 
  st_crop(st_bbox(grid)) %>% 
  select(autumn:summer) %>%
  as_tibble() %>%
  select(-geometry) %>% 
  as.matrix()

# dolphin detections/non-detections

y_dolphinS <- dfS %>% 
  filter(species == "dauphin") %>%
  select(autumn:summer) %>%
  as_tibble() %>%
  select(-geometry) %>% 
  as.matrix()
y_dolphinS[effortS == 0] <- NA
## ind_dolphinS <- apply(y_dolphinS, 1, function(x) all(is.na(x)))
## y_dolphinS <- y_dolphinS[ !ind_dolphinS, ]

# fishing boats detections/non-detections
y_fishingS <- dfS %>% 
  filter(species == "chalutier") %>%
  select(autumn:summer) %>%
  as_tibble() %>%
  select(-geometry) %>% 
  as.matrix()
y_fishingS[effortS == 0] <- NA
## ind_fishingS <- apply(y_fishingS, 1, function(x) all(is.na(x)))
## y_fishingS <- y_fishingS[ !ind_fishingS, ]

# grid cells coordinates
coordS <- dfS %>% 
  filter(species == "dauphin") %>%
  select(autumn:summer) %>%
  st_centroid() %>%
  st_coordinates() %>%
  as_tibble() %>%
  mutate(easting = (X - mean(X)) / sd(X), 
         northing = (Y - mean(Y)) / sd(Y)) %>%
  select(easting, northing) %>%
  as.matrix()
## maskS <- apply(effortS == 0, 1, sum) == 4
## coordS <- coordS[!maskS,]
dim(coordS)

# means and standard deviations used to standardise the grid cells coordinates
tempS <- dfS %>% 
  filter(species == "dauphin") %>%
  st_centroid() %>%
  st_coordinates() %>%
  as.matrix() 
meanXS <- mean(tempS[,1])
sdXS <- sd(tempS[,1])
meanYS <- mean(tempS[,2])
sdYS <- sd(tempS[,2])
```

## GDEGeM

Visualise data.

```{r message=FALSE, warning=FALSE, echo = FALSE}
dfG <- bind_rows(multioccu_gd$dauphins %>% add_column(species = "dauphin"), 
          multioccu_gd$chalut %>% add_column(species = "chalutier")) %>% 
  st_crop(st_bbox(grid))

```

Build datasets.

```{r message=FALSE, warning=FALSE, echo = FALSE}
# sampling effort
effortG <- multioccu_gd$effort %>% 
  st_crop(st_bbox(grid)) %>% 
  select(autumn:summer) %>%
  as_tibble() %>%
  select(-geometry) %>% 
  as.matrix()

# dolphin detections/non-detections

y_dolphinG <- dfG %>% 
  filter(species == "dauphin") %>%
  select(autumn:summer) %>%
  as_tibble() %>%
  select(-geometry) %>% 
  as.matrix()
y_dolphinG[effortG == 0] <- NA
## ind_dolphinG <- apply(y_dolphinG, 1, function(x) all(is.na(x)))
## y_dolphinG <- y_dolphinG[ !ind_dolphinG, ]

# fishing boats detections/non-detections
y_fishingG <- dfG %>% 
  filter(species == "chalutier") %>%
  select(autumn:summer) %>%
  as_tibble() %>%
  select(-geometry) %>% 
  as.matrix()
y_fishingG[effortG == 0] <- NA
## ind_fishingG <- apply(y_fishingG, 1, function(x) all(is.na(x)))
## y_fishingG <- y_fishingG[ !ind_fishingG, ]

# grid cells coordinates
coordG <- dfG %>% 
  filter(species == "dauphin") %>%
  select(autumn:summer) %>%
  st_centroid() %>%
  st_coordinates() %>%
  as_tibble() %>%
  mutate(easting = (X - mean(X)) / sd(X), 
         northing = (Y - mean(Y)) / sd(Y)) %>%
  select(easting, northing) %>%
  as.matrix()
## maskG <- apply(effortG == 0, 1, sum) == 4
## coordG <- coordG[!maskG,]
dim(coordG)

# means and standard deviations used to standardise the grid cells coordinates
tempG <- dfG %>% 
  filter(species == "dauphin") %>%
  st_centroid() %>%
  st_coordinates() %>%
  as.matrix() 
meanXG <- mean(tempG[,1])
sdXG <- sd(tempG[,1])
meanYG <- mean(tempG[,2])
sdYG <- sd(tempG[,2])
```

## Joining the dataset and formatting for Bayesian analyses

Format data.

```{r message=FALSE, warning=FALSE, echo = FALSE}
yS <- list(y_dolphinS, y_fishingS)
yG <- list(y_dolphinG, y_fishingG)
names(yS) <- names(yS) <-  c('dolphin','fishing')

## ind_effortS <- apply(effortS, 1, sum)
cov_effortS <- effortS
cov_effortS[cov_effortS == 0] <- NA
st_effortS <- matrix(scale(cov_effortS), ncol = 4)

## ind_effortG <- apply(effortG, 1, sum)
cov_effortG <- effortG
cov_effortG[cov_effortG == 0] <- NA
st_effortG <- matrix(scale(cov_effortG), ncol = 4)
```

Let's format the data in a matrix with $N$ rows (sites) and $J$ columns (surveys) with in each cell a `1:16` for the observation (or event in the capture-recapture terminology) `none species detected`, `species A detected`, `species B detected`, `both species detected` and each of these event by either by SAMM only, by GDEGeM onyl, or by both monitoring programs.

```{r message=FALSE, warning=FALSE, echo = FALSE}
str(yS)
str(yG)
N <- nrow(yS[[1]])
J <- ncol(yG[[1]])
y_jagsS <- y_jagsG <- y_jags <-  matrix(NA, nrow = N, ncol = J)


# SAMM
for (j in 1:N){ #nsites
  for (k in 1:J){ #nocc
    if (is.na(yS[[1]][j,k])) next # if cell j is not sampled at occasion k, then next
    if (yS[[1]][j,k] == 0 & yS[[2]][j,k] == 0) y_jagsS[j,k] <- 1
    if (yS[[1]][j,k] == 1 & yS[[2]][j,k] == 0) y_jagsS[j,k] <- 2
    if (yS[[1]][j,k] == 0 & yS[[2]][j,k] == 1) y_jagsS[j,k] <- 3
    if (yS[[1]][j,k] == 1 & yS[[2]][j,k] == 1) y_jagsS[j,k] <- 4
  }
}

# GDEGeM
for (j in 1:N){ #nsites
  for (k in 1:J){ #nocc
    if (is.na(yG[[1]][j,k])) next # if cell j is not sampled at occasion k, then next
    if (yG[[1]][j,k] == 0 & yG[[2]][j,k] == 0) y_jagsG[j,k] <- 1
    if (yG[[1]][j,k] == 1 & yG[[2]][j,k] == 0) y_jagsG[j,k] <- 2
    if (yG[[1]][j,k] == 0 & yG[[2]][j,k] == 1) y_jagsG[j,k] <- 3
    if (yG[[1]][j,k] == 1 & yG[[2]][j,k] == 1) y_jagsG[j,k] <- 4
  }
}

head(y_jagsS, 25)
dim(y_jagsS)
dim(y_jagsG)
dim(st_effortG)
dim(st_effortS)
# Before joining, we do a trick to deal with NAs. We replace the NAs by 0 in where the couple site x occasion has been sampled by the other monitoring device

# for SAMM
backgdG <- st_effortG
backgdG[ !is.na(backgdG)] <- 0 # create a background matrix with the sampling effort of GDEGeM
y2S <- backgdG
y2S[ !is.na(y_jagsS)] <- y_jagsS[ !is.na(y_jagsS)] # add the detection of SAMM

# for GDEGeM
backgdS <- st_effortS
backgdS[ !is.na(backgdS)] <- 0 # create a background matrix with the sampling effort of SAMM
y2G <- backgdS
y2G[ !is.na(y_jagsG)] <- y_jagsG[ !is.na(y_jagsG)] # add the detection of GDEGeM
#length(which(y2G==0))/4

# Join the two matrix
# reminder 1 -> no detection, 2 -> dolphin, 3 -> fishing, 4 -> both species , ++ 0 -> no detection but site sampled
for (j in 1:N){ #nsites
  for (k in 1:J){ #nocc
    if (is.na(y2G[j,k]) & is.na(y2S[j,k])) next
    if (y2G[j,k] <= 1 & y2S[j,k] <= 1) y_jags[j,k] <- 1
    if (y2G[j,k] == 2 & y2S[j,k] <= 1) y_jags[j,k] <- 2
    if (y2G[j,k] == 3 & y2S[j,k] <= 1) y_jags[j,k] <- 3
    if (y2G[j,k] == 4 & y2S[j,k] <= 1) y_jags[j,k] <- 4
    if (y2G[j,k] <= 1 & y2S[j,k] == 2) y_jags[j,k] <- 5
    if (y2G[j,k] == 2 & y2S[j,k] == 2) y_jags[j,k] <- 6
    if (y2G[j,k] == 3 & y2S[j,k] == 2) y_jags[j,k] <- 7
    if (y2G[j,k] == 4 & y2S[j,k] == 2) y_jags[j,k] <- 8
    if (y2G[j,k] <= 1 & y2S[j,k] == 3) y_jags[j,k] <- 9
    if (y2G[j,k] == 2 & y2S[j,k] == 3) y_jags[j,k] <- 10
    if (y2G[j,k] == 3 & y2S[j,k] == 3) y_jags[j,k] <- 11
    if (y2G[j,k] == 4 & y2S[j,k] == 3) y_jags[j,k] <- 12
    if (y2G[j,k] <= 1 & y2S[j,k] == 4) y_jags[j,k] <- 13
    if (y2G[j,k] == 2 & y2S[j,k] == 4) y_jags[j,k] <- 14
    if (y2G[j,k] == 3 & y2S[j,k] == 4) y_jags[j,k] <- 15
    if (y2G[j,k] == 4 & y2S[j,k] == 4) y_jags[j,k] <- 16
  }
}

# apply mask to remove site without sampling effort from none of the monitoring program
# revoir
 ind_effort <- apply(y_jags, 1, function(x) all(is.na(x)))
 y <- y_jags[ !ind_effort, ]
 seffG <- st_effortG[ !ind_effort, ]
 seffS <- st_effortS[ !ind_effort, ]
 effindG <- seffG
 effindG[is.na(effindG)] <- 0
 effindG[effindG !=0] <- 1
 
  effindS <- seffS
 effindS[is.na(effindS)] <- 0
 effindS[effindS !=0] <- 1
 
 seffG[is.na(seffG)] <- 0
 seffS[is.na(seffS)] <- 0
 
# same mask with coordG,coordS
 coordMask <- coordG[ !ind_effort, ]
```

## Do logistic regressions on detections

```{r}
# table 
table(y)

# test with logistic reg
yG[[1]][is.na(yG[[1]])] <- 0
yG[[2]][is.na(yG[[2]])] <- 0
y_turG <- apply(yG[[1]][!ind_effort,],1,max)
y_fisG <- apply(yG[[2]][!ind_effort,],1,max)

fit <- glm( y_turG ~ as_factor(y_fisG), offset = rowSums(seffG), family =binomial)
summary(fit)
```

```{r}
# samm
yS[[1]][is.na(yS[[1]])] <- 0
yS[[2]][is.na(yS[[2]])] <- 0
y_turS <- apply(yS[[1]][!ind_effort,],1,max)
y_fisS <- apply(yS[[2]][!ind_effort,],1,max)

sum(y_fisS)
sum(y_turS)
fitS <- glm( y_turS ~ as_factor(y_fisS), offset = rowSums(seffS), family =binomial)
summary(fitS)
```

```{r}
# both
y_tur <- y_turG + y_turS
y_fis <- y_fisG + y_fisS
y_tur[y_tur > 1] <- 1
y_fis[y_fis > 1] <- 1

sum(y_tur)
sum(y_fis)

fit <- glm( y_tur ~ as_factor(y_fis), offset = rowSums(seffS+ seffG), family =binomial)
summary(fit)
```


# Full IMSO w/ constant natural parameters, and GAM sur lat/long; detection is function of sampling effort plus dolphin detection function of pres/abs of fishing boats

Get the ingredients for GAMs using package `jagam` developed by Simon Wood and basically hacks what is built by the package `mgcv`.

```{r message=FALSE, warning=FALSE}
yy_dolphin <- apply(y, 1, max, na.rm = TRUE)
yy_dolphin[yy_dolphin ==1] <- 0
yy_dolphin[yy_dolphin >1] <- 1

coordx <- coordMask[,1]
coordy <- coordMask[,2]
stbathy <- mt$bathy.sc[!ind_effort,1]
library(mgcv)
res <- jagam(yy_dolphin ~ s(stbathy) + s(coordx, coordy, bs = "gp"), 
            family = "binomial",
            file = "psi.txt") # same structure for fishing boats and both together
#save(res, file = 'jagam.RData')
```

<!-- # model { -->

<!-- #   eta <- X %*% b ## linear predictor -->

<!-- #   for (i in 1:n) { mu[i] <-  ilogit(eta[i]) } ## expected response -->

<!-- #   for (i in 1:n) { y[i] ~ dbin(mu[i],w[i]) } ## response  -->

<!-- #   ## Parametric effect priors CHECK tau=1/10^2 is appropriate! -->

<!-- #   for (i in 1:1) { b[i] ~ dnorm(0,0.01) } -->

<!-- #   ## prior for s(coordx,coordy)...  -->

<!-- #   K1 <- S1[1:32,1:32] * lambda[1]  + S1[1:32,33:64] * lambda[2] -->

<!-- #   b[2:33] ~ dmnorm(zero[2:33],K1)  -->

<!-- #   ## smoothing parameter priors CHECK... -->

<!-- #   for (i in 1:2) { -->

<!-- #     lambda[i] ~ dgamma(.05,.005) -->

<!-- #     rho[i] <- log(lambda[i]) -->

<!-- #   } -->

<!-- # } -->

We do it in NIMBLE because the MCMC run is 10 times faster than that of JAGS.

## BUGS model

```{r eval = FALSE, include=TRUE }
IMSOfull <- nimbleCode({ 
  
  ## state process
  for(j in 1:nsite){
    z[j] ~ dcat(psi[j, 1:4])
  }
  # occupancy probabilities
  
    psi[1:nsite, 1] <- 1 / (1 + sum(prop[1:nsite, 1:3])) # unoccupied
    psi[1:nsite, 2] <- prop[1:nsite, 1] / (1 + sum(prop[1:nsite, 1:3])) # occupied by species A and not B
    psi[1:nsite, 3] <- prop[1:nsite, 2] / (1 + sum(prop[1:nsite, 1:3])) # occupied by species B and not A
    psi[1:nsite, 4] <- prop[1:nsite, 3] / (1 + sum(prop[1:nsite, 1:3])) # occupied by both species A and B
  
  ## observation process
  for(j in 1:nsite) {
    for(k in 1:nyear) {
      y[j, k] ~ dcat(obs[j, k, 1:16, z[j]])
    }
  }
  
  # detection matrix with obs for observations and state = true states
  # obs take values: 
  ## VL: INSANE 
  ## Let's have a bit of explanation, we have species A, and B. We have monitoring S through SAMM, and G through GDEGeM
  ## Then, we have 16 different situations
  # 1 for none species detected neither by G nor S
  # 2 for species A detected by G, nothing by S
  # 3 for species B detected by G, nothing by S
  # 4 for both species detected by G, nothing by S
  
  # 5 for none species detected neither by G, species A detected by S
  # 6 for species A detected by G, species A detected by S
  # 7 for species B detected by G, species A detected by S
  # 8 for both species detected by G, species A detected by S
  
  # 9 for none species detected neither by G, species B detected by S
  # 10 for species A detected by G, species B detected by S
  # 11 for species B detected by G, species B detected by S
  # 12 for both species detected by G, species B detected by S
  
  # 13 for none species detected neither by G, both species detected by S
  # 14 for species A detected by G, both species detected by S
  # 15 for species B detected by G, both species detected by S
  # 16 for both species detected by G, both species detected by S
  
  # given state = unoccupied,
  for(j in 1:nsite) {
    for(k in 1:nyear) {
      # state 1 = no species use the site
      obs[j, k, 1,  1] <- 1 # prob obs = 1 
      obs[j, k, 2,  1] <- 0 # prob obs = 2
      obs[j, k, 3,  1] <- 0 # prob obs = 3
      obs[j, k, 4,  1] <- 0 # prob obs = 4
      obs[j, k, 5,  1] <- 0 # prob obs = 5 
      obs[j, k, 6,  1] <- 0 # prob obs = 6
      obs[j, k, 7,  1] <- 0 # prob obs = 7
      obs[j, k, 8,  1] <- 0 # prob obs = 8
      obs[j, k, 9,  1] <- 0 # prob obs = 9 
      obs[j, k, 10, 1] <- 0 # prob obs = 10
      obs[j, k, 11, 1] <- 0 # prob obs = 11
      obs[j, k, 12, 1] <- 0 # prob obs = 12
      obs[j, k, 13, 1] <- 0 # prob obs = 13 
      obs[j, k, 14, 1] <- 0 # prob obs = 14
      obs[j, k, 15, 1] <- 0 # prob obs = 15
      obs[j, k, 16, 1] <- 0 # prob obs = 16
      
      # given state 2 = occupied by species A and not B,
      obs[j, k, 1,  2] <- 1 - pAg[j,k] - pAs[j,k] + pAg[j,k] * pAs[j,k] # prob obs = 1 
      obs[j, k, 2,  2] <- pAg[j,k] * (1 - pAs[j,k]) # prob obs = 2
      obs[j, k, 3,  2] <- 0 # prob obs = 3
      obs[j, k, 4,  2] <- 0 # prob obs = 4
      obs[j, k, 5,  2] <- pAs[j,k] * (1 - pAg[j,k]) # prob obs = 5 
      obs[j, k, 6,  2] <- pAs[j,k] * pAg[j,k] # prob obs = 6
      obs[j, k, 7,  2] <- 0 # prob obs = 7
      obs[j, k, 8,  2] <- 0 # prob obs = 8
      obs[j, k, 9,  2] <- 0 # prob obs = 9 
      obs[j, k, 10, 2] <- 0 # prob obs = 10
      obs[j, k, 11, 2] <- 0 # prob obs = 11
      obs[j, k, 12, 2] <- 0 # prob obs = 12
      obs[j, k, 13, 2] <- 0 # prob obs = 13 
      obs[j, k, 14, 2] <- 0 # prob obs = 14
      obs[j, k, 15, 2] <- 0 # prob obs = 15
      obs[j, k, 16, 2] <- 0 # prob obs = 16
      
      # given state 3 = occupied by species B and not A,
      obs[j, k, 1,  3] <- 1 - pBg[j,k] - pBs[j,k] + pBg[j,k] * pBs[j,k] # prob obs = 1 
      obs[j, k, 2,  3] <- 0 # prob obs = 2
      obs[j, k, 3,  3] <- pBg[j,k] * (1 - pBs[j,k]) # prob obs = 3
      obs[j, k, 4,  3] <- 0 # prob obs = 4
      obs[j, k, 5,  3] <- 0 # prob obs = 5 
      obs[j, k, 6,  3] <- 0 # prob obs = 6
      obs[j, k, 7,  3] <- 0 # prob obs = 7
      obs[j, k, 8,  3] <- 0 # prob obs = 8
      obs[j, k, 9,  3] <- pBs[j,k] * (1 - pBg[j,k]) # prob obs = 9 
      obs[j, k, 10, 3] <- 0 # prob obs = 10
      obs[j, k, 11, 3] <- pBs[j,k] * pBg[j,k] # prob obs = 11
      obs[j, k, 12, 3] <- 0 # prob obs = 12
      obs[j, k, 13, 3] <- 0 # prob obs = 13 
      obs[j, k, 14, 3] <- 0 # prob obs = 14
      obs[j, k, 15, 3] <- 0 # prob obs = 15
      obs[j, k, 16, 3] <- 0 # prob obs = 16
      
      # given state 4 = occupied by both species B and A,
      # VL: Now it's fun...
      obs[j, k, 1,  4] <- (1 - pAs[j,k]) * (1 - pAg[j,k]) * (1- pBs[j,k]) * (1 - pBg[j,k]) # prob obs = 1 
      obs[j, k, 2,  4] <- (1 - pAs[j,k]) * (1 - pBs[j,k]) * pAg[j,k] * (1 - pBg[j,k]) # prob obs = 2
      obs[j, k, 3,  4] <- (1 - pAs[j,k]) * (1 - pBs[j,k]) * pBg[j,k] * (1 - pAg[j,k]) # prob obs = 3
      obs[j, k, 4,  4] <- (1 - pAs[j,k]) * (1 - pBs[j,k]) * pAg[j,k] * pBg[j,k]   # prob obs = 4
      obs[j, k, 5,  4] <- pAs[j,k]*(1 - pBs[j,k]) * (1 - pAg[j,k]) * (1 - pBg[j,k]) ### # prob obs = 5 
      obs[j, k, 6,  4] <- pAs[j,k]*(1 - pBs[j,k]) * pAg[j,k] * (1 - pBg[j,k])  # pr ### # prob obs = 6
      obs[j, k, 7,  4] <- pAs[j,k]*(1 - pBs[j,k]) * pBg[j,k] * (1 - pAg[j,k]) # pro ### # prob obs = 7
      obs[j, k, 8,  4] <- pAs[j,k]*(1 - pBs[j,k]) * pAg[j,k] * pBg[j,k]  # prob obs ### # prob obs = 8
      obs[j, k, 9,  4] <- pBs[j,k]*(1 - pAs[j,k]) * (1 - pAg[j,k]) * (1 - pBg[j,k])  # prob obs = 9 
      obs[j, k, 10, 4] <- pBs[j,k]*(1 - pAs[j,k]) * pAg[j,k] * (1 - pBg[j,k])  # prob obs = 10
      obs[j, k, 11, 4] <- pBs[j,k]*(1 - pAs[j,k]) * pBg[j,k] * (1 - pAg[j,k]) # prob obs = 11
      obs[j, k, 12, 4] <- pBs[j,k]*(1 - pAs[j,k]) * pAg[j,k] * pBg[j,k]  # prob obs = 12
      obs[j, k, 13, 4] <- pAs[j,k] * pBs[j,k] * (1 - pAg[j,k]) * (1 - pBg[j,k]) # prob obs = 13 
      obs[j, k, 14, 4] <- pAs[j,k] * pBs[j,k] * pAg[j,k] * (1 - pBg[j,k]) # prob obs = 14
      obs[j, k, 15, 4] <- pAs[j,k] * pBs[j,k] * pBg[j,k] * (1 - pAg[j,k]) # prob obs = 15
      obs[j, k, 16, 4] <- pAs[j,k] * pAg[j,k] * pBs[j,k] * pBg[j,k] # prob obs = 16
    }
  }  
 ## priors for...
 # occupancy probabilities

 for(j in 1:nsite) {
    log(prop[j, 1]) <- theta1[j] 
    log(prop[j, 2]) <- theta2[j] 
    log(prop[j, 3]) <- theta3[j]
  }
  
  theta1[1:nsite] <- X[1:nsite,1:33] %*% b1[1:33] ## linear predictor
  theta2[1:nsite] <- X[1:nsite,1:33] %*% b2[1:33] ## linear predictor
  theta3[1:nsite] <- X[1:nsite,1:33] %*% b3[1:33] ## linear predictor

    b1[1] ~ dnorm(0,0.01) 
    b2[1] ~ dnorm(0,0.01) 
    b3[1] ~ dnorm(0,0.01) 

 ## prior for s(bathy) 
  K11[1:9,1:9] <- S1[1:9,1:9] * lambda[1, 1]  + S1[1:9,10:18] * lambda[2, 1]
  K12[1:9,1:9] <- S1[1:9,1:9] * lambda[1, 2]  + S1[1:9,10:18] * lambda[2, 2]
  K13[1:9,1:9] <- S1[1:9,1:9] * lambda[1, 3]  + S1[1:9,10:18] * lambda[2, 3]
  b1[2:10] ~ dmnorm(zero[2:10], K11[1:9,1:9]) 
  b2[2:10] ~ dmnorm(zero[2:10], K12[1:9,1:9]) 
  b3[2:10] ~ dmnorm(zero[2:10], K13[1:9,1:9]) 

  ## prior for s(coordx,coordy) 
  K21[1:32,1:32] <- S2[1:32,1:32] * lambda[3, 1]  + S2[1:32,33:64] * lambda[4, 1]
  K22[1:32,1:32] <- S2[1:32,1:32] * lambda[3, 2]  + S2[1:32,33:64] * lambda[4, 2]
  K23[1:32,1:32] <- S2[1:32,1:32] * lambda[3, 3]  + S2[1:32,33:64] * lambda[4, 3]
  b1[11:42] ~ dmnorm(zero[11:42], K21[1:32,1:32]) 
  b2[11:42] ~ dmnorm(zero[11:42], K22[1:32,1:32]) 
  b3[11:42] ~ dmnorm(zero[11:42], K23[1:32,1:32]) 
  
  ## smoothing parameter priors
  for (i in 1:4) {
    for (kk in 1:3){
      lambda[i, kk] ~ dgamma(.05,.005)
      rho[i, kk] <- log(lambda[i, kk])
    }
  }
  # detection probabilities (pA function of pres/abs of B, as in Waddle et al 2010 page 1470)
  # VL: There are four detections probabilities now pAs, pAg, pBg, pBs
  for(j in 1:nsite) {
     B_present[j] <- equals(z[j],3) + equals(z[j],4) #psi[j, 3] + psi[j, 4]
     
    for(k in 1:nyear) {
    pAs[j, k] <- (1/(1 + exp(-(beta[1] + beta[2] * B_present[j] + beta[3] * effS[j, k]))))*effindS[j,k]  
    
    pBs[j, k] <- (1/(1 + exp(-(beta[4] + beta[5] * effS[j, k]))))*effindS[j,k] 
                                                      
  pAg[j, k] <- (1/(1 + exp(-(beta[6] + beta[7] *  B_present[j] + beta[8] * effG[j, k])))) *effindG[j,k] 
    
    pBg[j, k] <- (1 /(1+ exp(-(beta[9] + beta[10] * effG[j, k]))))*effindG[j,k] 
    
    }
  }
  for (i in 1:10){
    beta[i] ~ dnorm(0,1)
  }
})
```

## Bundle data

Specify data, initial values, parameters to be monitored and various MCMC details:

```{r eval = FALSE, include=FALSE}
# nimble
y[is.na(y)] <-  1
data <- list(y = y, 
             effS = seffS,
             effG = seffG,
             effindS = effindS,
             effindG = effindG,
              X = res$jags.data$X, # gam para
             S1 = res$jags.data$S1,
             S2 = res$jags.data$S2,
             zero = res$jags.data$zero)

constants <- list(nsite = dim(y)[1], 
             nyear = dim(y)[2])

# Initial values for z {1:4} have to be consistent with the detection {1:16}

zinit <- matrix(NA, nrow = dim(y)[1], ncol = dim(y)[2])
zinit <- rep(1, dim(y)[1])

y[is.na(y)] <- 1
for (i in 1:dim(y)[1]){
  d <- f <- b <- 0
  for(j in 1:dim(y)[2]){
    if (y[i,j] == 2 | y[i,j] == 5 | y[i,j] == 6) {d <- 1}
    if (y[i,j] == 3 | y[i,j] == 9 | y[i,j] == 11) {f <- 1} 
    if (y[i,j] == 4 | y[i,j] == 7 | y[i,j] == 8 | y[i,j] == 10 | y[i,j] == 12
        | y[i,j] == 13 | y[i,j] == 14 | y[i,j] == 15| y[i,j] == 16 ) {b <- 1}
    } #j
  if(d == 1 & f == 0 & b == 0) {zinit[i] <- 2}
  if(d == 0 & f == 1 & b == 0) {zinit[i] <- 3}
  if(b == 1) {zinit[i] <- 4}
  if(d == 1 & f ==1) {zinit[i] <- 4}
}#i

# table
table(zinit)

inits <- list(z = zinit, 
              beta = rnorm(10, 0, 1), 
              lambda = cbind(res$jags.ini$lambda, res$jags.ini$lambda, res$jags.ini$lambda),
              b1 = res$jags.ini$b,
              b2 = res$jags.ini$b,
              b3 = res$jags.ini$b)
```

## Build model

```{r eval = FALSE, include=TRUE}
Rmodel <- nimbleModel(IMSOfull, constants, data, inits)
Rmodel$initializeInfo()
Rmodel$calculate() # _1736.923

conf <- configureMCMC(Rmodel)
conf$printMonitors() 
conf$addMonitors("z")

conf$printSamplers(byType= TRUE)

  # RWblock sampler
  conf$removeSampler(target = c("beta"))
  conf$addSampler(target = c("beta[1]","beta[2]","beta[3]"), type = "RW_block")
  conf$addSampler(target = c("beta[4]","beta[5]"), type = "RW_block")
  conf$addSampler(target = c("beta[6]","beta[7]","beta[8]"), type = "RW_block")
  conf$addSampler(target = c("beta[9]","beta[10]"), type = "RW_block")

  conf$printSamplers(byType= TRUE)


  # Build and compile MCMC
  Rmcmc <- buildMCMC(conf)
  Cmodel <- compileNimble(Rmodel)
  Cmcmc <- compileNimble(Rmcmc, project = Cmodel)
  
   t <- system.time(samples2 <- runMCMC(Cmcmc, niter = 1000000, nburnin = 40000, nchains = 2, thin = 5, samplesAsCodaMCMC = TRUE))
   #ART nit = 5000 nb = 1000, nc = 3, t = 185 sec
  
str(samples2)
code = Rmodel$getCode()
save(samples2, code, file ="IMSO_1Mit.rdata")

```

## Deal with output

Convergence checkings

```{r echo=FALSE}
library(coda)

load("IMSO_1Mit.rdata")

den <- mcmcplots::denplot(as.mcmc.list(samples2[,c(
"beta[1]","beta[2]",
"beta[3]","beta[4]",
"beta[5]","beta[6]",
"beta[7]","beta[8]",
"beta[9]")]))

mcmcplots::denplot(as.mcmc.list(samples2[,c(
"lambda[1, 1]","lambda[2, 1]",
"lambda[3, 1]","lambda[4, 1]",
"lambda[1, 2]","lambda[2, 2]",
"lambda[3, 2]","lambda[4, 3]",
"lambda[3, 3]")]))

if(FALSE){
tra <- mcmcplots::traplot(as.mcmc.list(samples2[,c(
"beta[1]","beta[2]",
"beta[3]","beta[4]",
"beta[5]","beta[6]",
"beta[7]","beta[8]",
"beta[9]")]))
}

if(FALSE){
# effSize
ess <- apply(samples2$chain1,2, effectiveSize)
ess2 <- apply(samples2$chain2,2, effectiveSize)

essT <- ess + ess2
min(essT)
# z obs 
table(zinit)
# z est 
samples <- rbind(samples2[[1]], samples2[[2]])
Best <- samples[,1:279]
table(apply(Best,2,median))
}
```

```{r include=FALSE}
beta1 <- c(samples2$chain1[, 'beta[1]'] , samples2$chain2[, 'beta[1]'],samples2$chain3[, 'beta[1]'])
beta2 <- c(samples2$chain1[, 'beta[2]'] , samples2$chain2[, 'beta[2]'],samples2$chain3[, 'beta[2]'])
beta3 <- c(samples2$chain1[, 'beta[3]'] , samples2$chain2[, 'beta[3]'],samples2$chain3[, 'beta[3]'])
beta4 <- c(samples2$chain1[, 'beta[4]'] , samples2$chain2[, 'beta[4]'],samples2$chain3[, 'beta[4]'])
beta5 <- c(samples2$chain1[, 'beta[5]'] , samples2$chain2[, 'beta[5]'],samples2$chain3[, 'beta[5]'])
beta6 <- c(samples2$chain1[, 'beta[6]'] , samples2$chain2[, 'beta[6]'],samples2$chain3[, 'beta[6]'])
beta7 <- c(samples2$chain1[, 'beta[7]'] , samples2$chain2[, 'beta[7]'],samples2$chain3[, 'beta[7]'])
beta8 <- c(samples2$chain1[, 'beta[8]'] , samples2$chain2[, 'beta[8]'],samples2$chain3[, 'beta[8]'])
beta9 <- c(samples2$chain1[, 'beta[9]'] , samples2$chain2[, 'beta[9]'],samples2$chain3[, 'beta[9]'])
beta10 <- c(samples2$chain1[,'beta[10]'], samples2$chain2[,'beta[10]'],samples2$chain3[,'beta[10]'])

beta <- bind_cols(values = c(beta1, beta2,beta3,beta4,beta5,
                             beta6, beta7, beta8,beta9, beta10), para = c(rep("Int1",length(beta1)),rep("Effect_ChalutS",length(beta2)),                        rep("SeffS_onTur",length(beta3)),rep("Int2",length(beta4)),
  rep("SeffS_onTra",length(beta5)), rep("Int3",length(beta6)),
  rep("Effect_TrawG",length(beta7)), rep("SeffG_onTur",length(beta8)),
  rep("Int4",length(beta9)), rep("SeffG_onTra",length(beta10))))
ggplot(data=beta) + geom_violin(aes(x = para, y = values, fill = para))
```

First, get the whole grid.

```{r message=FALSE, warning=FALSE, include=FALSE}
grid_coord <- grid %>%
  st_centroid() %>%
  st_coordinates() %>%
  as_tibble() %>%
  mutate(easting = (X - meanXG)/sdXG,
         northing = (Y - meanYG)/sdYG)

grid_bathy <- sea %>% 
  st_crop(grid) %>% 
  st_transform(crs = st_crs(pays)) %>%
  st_crop(xmin = 700000, xmax = 900000, ymin = 6140000, ymax = 6300000) %>%
  mutate(cov_bathy = bathy.sc[,1]) %>%
  pull(cov_bathy )
```

Second, get linear predictor.

```{r include=FALSE}
sm_bathy <- smoothCon(s(bathy), 
                          data = data.frame(bathy = grid_bathy,
                                            coordx = grid_coord$easting, 
                                            coordy = grid_coord$northing), 
                          absorb.cons = TRUE) 

sm_xy <- smoothCon(s(coordx, coordy, bs = "gp"), 
                          data = data.frame(bathy = grid_bathy,
                                            coordx = grid_coord$easting, 
                                            coordy = grid_coord$northing), 
                          absorb.cons = TRUE) 

Xp_bathy <- PredictMat(sm_bathy[[1]], data.frame(bathy = grid_bathy,
                                     coordx = grid_coord$easting, 
                                     coordy = grid_coord$northing))
Xp_xy <- PredictMat(sm_xy[[1]], data.frame(bathy = grid_bathy,
                                     coordx = grid_coord$easting, 
                                     coordy = grid_coord$northing))
Xp <- cbind(1, Xp_bathy, Xp_xy)

# bind the 2 chains
samplesExt <- as_tibble(rbind(samples2$chain1, samples2$chain2, samples2$chain3))

names(samplesExt)
# matrix nit x 33 
b1 <- as.matrix(samplesExt[,1:42])
b2 <- as.matrix(samplesExt[,43:84])
b3 <- as.matrix(samplesExt[,85:126])

#dim(Xp)
#dim(b1)

mu1 <- matrix(NA, nrow = nrow(Xp), ncol = nrow(b1))
mu2 <- matrix(NA, nrow = nrow(Xp), ncol = nrow(b2))
mu3 <- matrix(NA, nrow = nrow(Xp), ncol = nrow(b3))
for (i in 1:nrow(b1)){
  mu1[1:nrow(Xp), i] <- Xp %*% b1[i,]
  mu2[1:nrow(Xp), i] <- Xp %*% b2[i,]
  mu3[1:nrow(Xp), i] <- Xp %*% b3[i,]
}

prop1 <- apply(exp(mu1), 1, median)
prop2 <- apply(exp(mu2), 1, median)
prop3 <- apply(exp(mu3), 1, median)

psi1 <- plogis(prop1) / (1 + plogis(prop1) + plogis(prop2) + plogis(prop3))
psi2 <- plogis(prop2) / (1 + plogis(prop1) + plogis(prop2) + plogis(prop3))
psi3 <- plogis(prop3) / (1 + plogis(prop1) + plogis(prop2) + plogis(prop3))
psi0 <- 1 - (psi1 + psi2 + psi3)
```

Third, get occupancy probabilities.

```{r echo=FALSE}
# Marginal probabilities.
#psi1 + psi3 # Pr(dolphin present)
#psi2 + psi3 # Pr(fishing present)
#psi2 + psi0 # Pr(dolphin absent)
#psi1 + psi0 # Pr(fishing absent)

# Conditional probabilities.
#psi1 / (psi1 + psi0) # Pr(dolphin present | fishing absent) ?= Pr(dolphin present)
#psi3 / (psi3 + psi2) # Pr(dolphin present | fishing present) ?= Pr(dolphin present)
#psi2 / (psi2 + psi0) # Pr(fishing present | dolphin absent) = Pr(fishing)
#psi3 / (psi3 + psi1) # Pr(fishing present | dolphin present) = Pr(fishing)
```

# Plot figures

## The map of coocurrences probabilities

```{r echo=FALSE}
cooc <- unique(c(which(y[,1] %in% c(4,8,12,16)), which(y[,2] %in% c(4,8,12,16)), which(y[,3] %in% c(4,8,12,16)),
                 which(y[,4] %in% c(4,8,12,16)) ))
  
 ggplot() + 
  geom_sf(data = grid, lwd = 0.1, aes(fill = (psi3))) +
  geom_sf(data = pays) + 
  scale_fill_viridis_c(name = "") +
 labs(title = "Probabilité de co-occurrence dauphins et chalutiers", 
       subtitle = "estimée avec un modèle d'occupancy à 2 espèces",
       caption = "Source : SAMM & GDEGeM data")
```

## Maps of dolphin and trawlers space-use probabilities

```{r echo=FALSE}
dof <- unique(c(which(y[,1] %in% c(2,4,5,6,7,8,10,12,13,14,15,16)), which(y[,2] %in% c(2,4,5,6,7,8,10,12,13,14,15,16)), which(y[,3] %in% c(2,4,5,6,7,8,10,12,13,14,15,16)),
                 which(y[,4] %in% c(2,4,5,6,7,8,10,12,13,14,15,16)) ))

traw <- unique(c(which(y[,1] %in% c(3,4,7,8,9,10,11,12,13,14,15,16)), which(y[,2] %in% c(3,4,7,8,9,10,11,12,13,14,15,16)), which(y[,3] %in% c(3,4,7,8,9,10,11,12,13,14,15,16)),
                 which(y[,4] %in% c(3,4,7,8,9,10,11,12,13,14,15,16)) ))

# proba dauphin = psi1 + psi3
map_dofin <- ggplot() + 
  geom_sf(data = grid, lwd = 0.1, aes(fill = c(psi3 + psi1))) +
  geom_sf(data = pays) + 
  scale_fill_viridis_c(name = "", limits = c(0,1)) +
  labs(title = "Bottlenose dolphins space-use prob.", subtitle = "psi3 + psi1", 
       caption = "Source : SAMM & GDEGeM data")

map_dofinCpres <- ggplot() + 
  geom_sf(data = grid, lwd = 0.1, aes(fill = c(psi3 / (psi3+ psi2)))) +
  geom_sf(data = pays) + 
  scale_fill_viridis_c(name = "") +
  labs(title = "Prob. dauphin cond. trawlers",  subtitle = "psi3 / (psi3 +psi2)", 
       caption = "Source : SAMM & GDEGeM data")

map_dofinCabs <- ggplot() + 
  geom_sf(data = grid, lwd = 0.1, aes(fill = c(psi1 / (psi1 + psi0)))) +
  geom_sf(data = pays) + 
  scale_fill_viridis_c(name = "") +
  labs(title = "Prob. dauphin cond. no trawlers",  subtitle = "psi1 / (psi1 +psi0)", 
       caption = "Source : SAMM & GDEGeM data")

map_dofinSeul <- ggplot() + 
  geom_sf(data = grid, lwd = 0.1, aes(fill = c(psi1 ))) +
  geom_sf(data = pays) + 
  scale_fill_viridis_c(name = "") +
  labs(title = "Prob. dauphin seul",  subtitle = "psi1 ", 
       caption = "Source : SAMM & GDEGeM data")

map_trawlerSeul <- ggplot() + 
  geom_sf(data = grid, lwd = 0.1, aes(fill = c(psi2 ))) +
  geom_sf(data = pays) + 
  scale_fill_viridis_c(name = "") +
  labs(title = "Prob. trawlers seul",  subtitle = "psi2 ", 
       caption = "Source : SAMM & GDEGeM data")

map_trawl <- ggplot() + 
  geom_sf(data = grid, lwd = 0.1, aes(fill = c(psi3 + psi2))) +
  geom_sf(data = pays) + 
  scale_fill_viridis_c(name = "", limits = c(0,1)) +
  labs(title = "Trawlers space-use prob.",  subtitle = "psi3 + psi2", 
       caption = "Source : SAMM & GDEGeM data")

(map_dofin/ map_trawl)
```
```{r echo=FALSE}
cowplot::plot_grid(map_dofinCpres,map_dofinCabs, map_dofinSeul,map_trawlerSeul, nrow = 2, ncol = 2)
```

Maps of detections 

```{r echo=FALSE}
map_detect <- ggplot()+
  geom_sf(data = grid %>% slice(traw), aes(fill = "chalutier")) +
  geom_sf(data = grid %>% slice(dof), aes(fill = "dauphin")) +
  geom_sf(data = grid %>% slice(cooc), aes(fill = "both")) + 
  geom_sf(data = pays) + 
  scale_fill_manual(values = c("dauphin" = "#fb8b24", "both" = "#0f4c5c" , "chalutier" = "#9a031e")) +
  labs(title= "Maps of detections")
map_detect
```

## The probability of detecting dolphins conditionnal on trawlers occurence

### For SAMM  

```{r echo=FALSE}
grid_p <- seq(range(seffS)[1], range(seffS)[2], length = 100) 
#grid_pfis <- seq(range(psi2+psi3)[1], range(psi2+psi3)[2], length = 100) 
effSBrut <- seq(range(effortS)[1],range(effortS)[2]/1000, length = 100)

nit <- length(beta1)

logit_p12 <- logit_p12bar <-logit_p2 <- matrix(NA, nrow = length(beta1), ncol = length(grid_p))

for(i in 1:length(grid_p)){
logit_p12[1:nit,i] <- plogis(beta1[1:nit]  + beta3[1:nit] * grid_p[i] + beta2[1:nit])
logit_p12bar[1:nit,i] <- plogis(beta1[1:nit]  + beta3[1:nit] * grid_p[i])
logit_p2[1:nit,i] <- plogis(beta4[1:nit]  + beta5[1:nit] * grid_p[i])
}

logitp12 <- apply(logit_p12, 2, median)
logitp12bar <- apply(logit_p12bar, 2, median)
logitp2 <- apply(logit_p2, 2, median)


logitp12min <- logitp12max <- logitp12barmin <- logitp12barmax <- logitp2min <- logitp2max <- rep(NA, ncol(logit_p12))

for(i in 1:ncol(logit_p12)){
  logitp12min[i] <- quantile(logit_p12[,i], 0.1)
  logitp12max[i] <- quantile(logit_p12[,i], 0.9)
  
  logitp12barmin[i] <- quantile(logit_p12bar[,i], 0.1)
  logitp12barmax[i] <- quantile(logit_p12bar[,i], 0.9)
  
  logitp2min[i] <- quantile(logit_p2[,i], 0.1)
  logitp2max[i] <- quantile(logit_p2[,i], 0.9)
}
  
psamm <- ggplot()+ 
  geom_ribbon(aes(x = effSBrut, ymin = logitp2min, ymax = logitp2max), fill = "#9a031e", alpha = 0.4) +
  geom_ribbon(aes(x = effSBrut, ymin = logitp12barmin, ymax = logitp12barmax), fill = "#0F4C5C", alpha =0.7) + 
  geom_ribbon(aes(x = effSBrut, ymin = logitp12min, ymax = logitp12max), fill = "#fb8b24", alpha = 0.3)+ 
  geom_line(aes(x = effSBrut, y = logitp12, color = "dauphin cond présence chalutier"),  lwd = 1) +
  geom_line(aes(x = effSBrut, y = logitp12bar, color = "dauphin cond absence chalutier"), lwd = 1) + 
  geom_line(aes(x = effSBrut, y = logitp2, color = "chalutier"), lwd = 1) +
  scale_color_manual(values = c("dauphin cond présence chalutier" = "#fb8b24", "dauphin cond absence chalutier" = "#0F4C5C" , "chalutier" = "#9a031e")) + 
  xlab("effort (km parcouru)") + ylab("probabilité estimée") + labs(title = "SAMM : probabilité de détection pour un...", color = "Legend")
```

### For GDEGeM  

```{r echo=FALSE}
grid_pg <- seq(range(seffG)[1], range(seffG)[2], length = 100) 
#grid_pfis <- seq(range(psi2+psi3)[1], range(psi2+psi3)[2], length = 100) 
effGBrut <- seq(range(effortG)[1],range(effortG)[2]/1000, length = 100)

nit <- length(beta1)

logit_p12g <- logit_p12barg <-logit_p2g <- matrix(NA, nrow = length(beta1), ncol = length(grid_pg))

for(i in 1:length(grid_pg)){
logit_p12g[1:nit,i] <- plogis(beta6[1:nit]  + beta8[1:nit] * grid_p[i] + beta7[1:nit])
logit_p12barg[1:nit,i] <- plogis(beta6[1:nit]  + beta8[1:nit] * grid_p[i])
logit_p2g[1:nit,i] <- plogis(beta9[1:nit]  + beta10[1:nit] * grid_p[i])
}

logitp12g <- apply(logit_p12g, 2, median)
logitp12barg <- apply(logit_p12barg, 2, median)
logitp2g <- apply(logit_p2g, 2, median)


logitp12ming <- logitp12maxg <- logitp12barming <- logitp12barmaxg <- logitp2ming <- logitp2maxg <- rep(NA, ncol(logit_p12g))

for(i in 1:ncol(logit_p12g)){
  logitp12ming[i] <- quantile(logit_p12g[,i], 0.1)
  logitp12maxg[i] <- quantile(logit_p12g[,i], 0.9)
  
  logitp12barming[i] <- quantile(logit_p12barg[,i], 0.1)
  logitp12barmaxg[i] <- quantile(logit_p12barg[,i], 0.9)
  
  logitp2ming[i] <- quantile(logit_p2g[,i], 0.1)
  logitp2maxg[i] <- quantile(logit_p2g[,i], 0.9)
}
  
pgdegem <- ggplot()+ 
  geom_ribbon(aes(x = effGBrut, ymin = logitp2ming, ymax = logitp2maxg), fill = "#9a031e", alpha = 0.4) +
  geom_ribbon(aes(x = effGBrut, ymin = logitp12barming, ymax = logitp12barmaxg), fill = "#0F4C5C", alpha =0.7) +
  geom_ribbon(aes(x = effGBrut, ymin = logitp12ming, ymax = logitp12maxg), fill = "#fb8b24", alpha = 0.3)+ 
  geom_line(aes(x = effGBrut, y = logitp12g, color = "dauphin cond présence chalutier"),  lwd = 1) + 
  geom_line(aes(x = effGBrut, y = logitp12barg, color = "dauphin cond absence chalutier"), lwd = 1) + 
  geom_line(aes(x = effGBrut, y = logitp2g, color = "chalutier"), lwd = 1) +
  scale_color_manual(values = c("dauphin cond présence chalutier" = "#fb8b24", "dauphin cond absence chalutier" = "#0F4C5C" , "chalutier" = "#9a031e")) + 
  xlab("effort (km parcouru)") + ylab("probabilité estimée") + labs(title = "GDEGeM : probabilité de détection pour un...", color = "Legend")
  
psamm / pgdegem
```
